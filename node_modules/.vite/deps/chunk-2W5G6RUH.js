import {
  Map_default
} from "./chunk-VO4GGOEJ.js";
import {
  Base_default
} from "./chunk-EPC4DRVJ.js";
import {
  asString
} from "./chunk-JGCWMTCG.js";
import {
  Object_default
} from "./chunk-7M2R3MTJ.js";
import {
  unByKey
} from "./chunk-64N4X4CB.js";

// node_modules/ol-ext/filter/Base.js
var ol_filter_Base = class olfilterBase extends Object_default {
  constructor(options) {
    super(options);
    this._listener = [];
    if (options && options.active === false) {
      this.set("active", false);
    } else {
      this.set("active", true);
    }
  }
  /** Activate / deactivate filter
  *	@param {boolean} b
  */
  setActive(b) {
    this.set("active", b === true);
  }
  /** Get filter active
  *	@return {boolean}
  */
  getActive() {
    return this.get("active");
  }
};
(function() {
  function precompose_(e) {
    if (this.get("active") && e.context) this.precompose(e);
  }
  function postcompose_(e) {
    if (this.get("active") && e.context) this.postcompose(e);
  }
  function filterRedraw_() {
    if (this.renderSync) {
      try {
        this.renderSync();
      } catch (e) {
      }
    } else {
      this.changed();
    }
  }
  function addFilter_(filter) {
    if (!this.filters_) this.filters_ = [];
    this.filters_.push(filter);
    if (filter.addToLayer) filter.addToLayer(this);
    if (filter.precompose) filter._listener.push({ listener: this.on(["precompose", "prerender"], precompose_.bind(filter)), target: this });
    if (filter.postcompose) filter._listener.push({ listener: this.on(["postcompose", "postrender"], postcompose_.bind(filter)), target: this });
    filter._listener.push({ listener: filter.on("propertychange", filterRedraw_.bind(this)), target: this });
    filterRedraw_.call(this);
  }
  function removeFilter_(filter) {
    var i;
    if (!this.filters_) this.filters_ = [];
    if (!filter) {
      this.filters_.forEach((function(f) {
        this.removeFilter(f);
      }).bind(this));
      return;
    }
    for (i = this.filters_.length - 1; i >= 0; i--) {
      if (this.filters_[i] === filter) this.filters_.splice(i, 1);
    }
    for (i = filter._listener.length - 1; i >= 0; i--) {
      if (filter._listener[i].target === this) {
        if (filter.removeFromLayer) filter.removeFromLayer(this);
        unByKey(filter._listener[i].listener);
        filter._listener.splice(i, 1);
      }
    }
    filterRedraw_.call(this);
  }
  Map_default.prototype.addFilter = function(filter) {
    console.warn("[OL-EXT] addFilter deprecated on map.");
    addFilter_.call(this, filter);
  };
  Map_default.prototype.removeFilter = function(filter) {
    removeFilter_.call(this, filter);
  };
  Map_default.prototype.getFilters = function() {
    return this.filters_ || [];
  };
  Base_default.prototype.addFilter = function(filter) {
    addFilter_.call(this, filter);
  };
  Base_default.prototype.removeFilter = function(filter) {
    removeFilter_.call(this, filter);
  };
  Base_default.prototype.getFilters = function() {
    return this.filters_ || [];
  };
})();
var Base_default2 = ol_filter_Base;

// node_modules/ol-ext/filter/Mask.js
var ol_filter_Mask = class olfilterMask extends Base_default2 {
  constructor(options) {
    options = options || {};
    super(options);
    if (options.feature) {
      switch (options.feature.getGeometry().getType()) {
        case "Polygon":
        case "MultiPolygon":
          this.feature_ = options.feature;
          break;
        default:
          break;
      }
    }
    this.set("inner", options.inner);
    this._fillColor = options.fill ? asString(options.fill.getColor()) || "rgba(0,0,0,0.2)" : "rgba(0,0,0,0.2)";
    this._shadowColor = options.shadowColor ? asString(options.shadowColor) || "rgba(0,0,0,0.5)" : "rgba(0,0,0,0.5)";
    this.set("shadowWidth", options.shadowWidth || 0);
    this.set("shadowMapUnits", options.shadowMapUnits === true);
  }
  /** Set filter fill color
   * @param {ol/colorLike} color
   */
  setFillColor(color) {
    this._fillColor = color ? asString(color) || "rgba(0,0,0,0.2)" : "rgba(0,0,0,0.2)";
  }
  /** Set filter shadow color
   * @param {ol/colorLike} color
   */
  setShadowColor(color) {
    this._shadowColor = color ? asString(color) || "rgba(0,0,0,0.5)" : "rgba(0,0,0,0.5)";
  }
  /** Draw the feature into canvas
   * @private
   */
  drawFeaturePath_(e, out) {
    var ctx = e.context;
    var canvas = ctx.canvas;
    var ratio = e.frameState.pixelRatio;
    var tr;
    if (e.frameState.coordinateToPixelTransform) {
      var m = e.frameState.coordinateToPixelTransform;
      if (e.inversePixelTransform) {
        var ipt = e.inversePixelTransform;
        tr = function(pt) {
          pt = [
            pt[0] * m[0] + pt[1] * m[1] + m[4],
            pt[0] * m[2] + pt[1] * m[3] + m[5]
          ];
          return [
            pt[0] * ipt[0] - pt[1] * ipt[1] + ipt[4],
            -pt[0] * ipt[2] + pt[1] * ipt[3] + ipt[5]
          ];
        };
      } else {
        tr = function(pt) {
          return [
            (pt[0] * m[0] + pt[1] * m[1] + m[4]) * ratio,
            (pt[0] * m[2] + pt[1] * m[3] + m[5]) * ratio
          ];
        };
      }
    } else {
      m = e.frameState.coordinateToPixelMatrix;
      tr = function(pt) {
        return [
          (pt[0] * m[0] + pt[1] * m[1] + m[12]) * ratio,
          (pt[0] * m[4] + pt[1] * m[5] + m[13]) * ratio
        ];
      };
    }
    var ll = this.feature_.getGeometry().getCoordinates();
    if (this.feature_.getGeometry().getType() === "Polygon")
      ll = [ll];
    function drawll(dx) {
      for (var l = 0; l < ll.length; l++) {
        var c = ll[l];
        for (var i2 = 0; i2 < c.length; i2++) {
          var pt = tr([c[i2][0][0] + dx, c[i2][0][1]]);
          ctx.moveTo(pt[0], pt[1]);
          for (var j = 1; j < c[i2].length; j++) {
            pt = tr([c[i2][j][0] + dx, c[i2][j][1]]);
            ctx.lineTo(pt[0], pt[1]);
          }
        }
      }
    }
    ctx.beginPath();
    if (out) {
      ctx.moveTo(-100, -100);
      ctx.lineTo(canvas.width + 100, -100);
      ctx.lineTo(canvas.width + 100, canvas.height + 100);
      ctx.lineTo(-100, canvas.height + 100);
      ctx.lineTo(-100, -100);
    }
    if (this.get("wrapX")) {
      var worldExtent = e.frameState.viewState.projection.getExtent();
      var worldWidth = worldExtent[2] - worldExtent[0];
      var extent = e.frameState.extent;
      var fExtent = this.feature_.getGeometry().getExtent();
      var fWidth = fExtent[2] - fExtent[1];
      var start = Math.floor((extent[0] - fWidth - worldExtent[0]) / worldWidth);
      var end = Math.floor((extent[2] + fWidth - worldExtent[2]) / worldWidth) + 1;
      if (start > end) {
        [start, end] = [end, start];
      }
      for (var i = start; i <= end; i++) {
        drawll(i * worldWidth);
      }
    } else {
      drawll(0);
    }
  }
  /**
   * @param {ol/Event} e 
   * @private
   */
  postcompose(e) {
    if (!this.feature_) return;
    var ctx = e.context;
    ctx.save();
    this.drawFeaturePath_(e, !this.get("inner"));
    ctx.fillStyle = this._fillColor;
    ctx.fill("evenodd");
    if (this.get("shadowWidth")) {
      var width = this.get("shadowWidth") * e.frameState.pixelRatio;
      if (this.get("shadowMapUnits")) width /= e.frameState.viewState.resolution;
      ctx.clip("evenodd");
      ctx.filter = "blur(" + width + "px)";
      ctx.strokeStyle = this._shadowColor;
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.lineWidth = width;
      ctx.stroke();
    }
    ctx.restore();
  }
};
var Mask_default = ol_filter_Mask;

export {
  Mask_default
};
//# sourceMappingURL=chunk-2W5G6RUH.js.map
