import "./chunk-TONY62YS.js";
import "./chunk-E67VJLA7.js";
import {
  element_default
} from "./chunk-CIOIU6T4.js";
import {
  Control_default
} from "./chunk-VO4GGOEJ.js";
import "./chunk-CNEHRA72.js";
import "./chunk-ZTMKVIRH.js";
import "./chunk-BHVDQB66.js";
import "./chunk-QO3WWC4I.js";
import "./chunk-VJP7GUU3.js";
import "./chunk-ALDHDZL6.js";
import {
  Fill_default,
  Stroke_default,
  Style_default,
  Text_default
} from "./chunk-ALJAW5IX.js";
import "./chunk-M3GPVIRK.js";
import "./chunk-EPC4DRVJ.js";
import {
  asString
} from "./chunk-JGCWMTCG.js";
import "./chunk-IEP2JX4U.js";
import "./chunk-C3SH46N7.js";
import "./chunk-FZBQY24O.js";
import "./chunk-BW4LB5FU.js";
import "./chunk-5D2XPBR2.js";
import "./chunk-PPP4FLHO.js";
import "./chunk-PKIQOAE4.js";
import "./chunk-MWTAL2FJ.js";
import "./chunk-FM44FOIC.js";
import "./chunk-EGHNAM74.js";
import "./chunk-WDVUUJVX.js";
import "./chunk-JFXZSSOM.js";
import "./chunk-27URL7KE.js";
import "./chunk-X57ZGWG5.js";
import "./chunk-44TYW2ZM.js";
import {
  transform
} from "./chunk-KPXKCNFP.js";
import "./chunk-3IXZBSVG.js";
import {
  getDistance
} from "./chunk-REEFJELK.js";
import "./chunk-3EZRJ7KS.js";
import "./chunk-QFCIXVZ3.js";
import "./chunk-7M2R3MTJ.js";
import {
  unByKey
} from "./chunk-64N4X4CB.js";
import "./chunk-5RHQVMYD.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/ol-ext/control/Dialog.js
var ol_control_Dialog = class olcontrolDialog extends Control_default {
  constructor(options) {
    options = options || {};
    if (options.fullscreen) options.target = document.body;
    var element = element_default.create("DIV", {
      className: ((options.className || "") + (options.zoom ? " ol-zoom" : "") + " ol-ext-dialog").trim()
    });
    super({
      element,
      target: options.target
    });
    element.addEventListener("click", (function(e) {
      if (this.get("hideOnBack") && e.target === element) this.close();
      if (this.get("hideOnClick")) this.close();
    }).bind(this));
    var form = element_default.create("FORM", {
      on: {
        submit: this._onButton("submit")
      },
      parent: element
    });
    element_default.create("H2", {
      parent: form
    });
    element_default.create("DIV", {
      className: "ol-closebox",
      click: this._onButton("cancel"),
      parent: form
    });
    element_default.create("DIV", {
      className: "ol-content",
      parent: form
    });
    this._progress = element_default.create("DIV", {
      style: { display: "none" },
      parent: form
    });
    var bar = element_default.create("DIV", {
      className: "ol-progress-bar",
      parent: this._progress
    });
    this._progressbar = element_default.create("DIV", {
      parent: bar
    });
    this._progressMessage = element_default.create("DIV", {
      className: "ol-progress-message",
      parent: this._progress
    });
    element_default.create("DIV", {
      className: "ol-buttons",
      parent: form
    });
    this.set("closeBox", options.closeBox !== false);
    this.set("zoom", !!options.zoom);
    this.set("hideOnClick", !!options.hideOnClick);
    this.set("hideOnBack", !!options.hideOnBack);
    this.set("className", element.className);
    this.set("closeOnSubmit", options.closeOnSubmit);
    this.set("buttons", options.buttons);
    this.setContent(options);
  }
  /** Show a new dialog
   * @param { * | Element | string } options options or a content to show
   *  @param {Element | String} options.content dialog content
   *  @param {string} options.title title of the dialog
   *  @param {string} options.className dialog class name
   *  @param {number} options.autoclose a delay in ms before auto close
   *  @param {boolean} options.hideOnBack close dialog when click the background
   *  @param {number} options.max if not null add a progress bar to the dialog
   *  @param {number} options.progress set the progress bar value
   *  @param {Object} options.buttons a key/value list of button to show
   *  @param {function} [options.onButton] a function that takes the button id and a list of input by className
   */
  show(options) {
    if (options) {
      if (options instanceof Element || typeof options === "string") {
        options = { content: options };
      }
      this.setContent(options);
    }
    this.element.classList.add("ol-visible");
    var input = this.element.querySelector('input[type="text"],input[type="search"],input[type="number"]');
    if (input)
      input.focus();
    this.dispatchEvent({ type: "show" });
    if (options) {
      if (options.autoclose) {
        var listener = setTimeout((function() {
          this.hide();
        }).bind(this), options.autoclose);
        this.once("hide", function() {
          clearTimeout(listener);
        });
      }
      if (options.hideOnBack) {
        var value = this.get("hideOnBack");
        this.set("hideOnBack", true);
        this.once("hide", (function() {
          this.set("hideOnBack", value);
        }).bind(this));
      }
    }
  }
  /** Open the dialog
   */
  open() {
    this.show();
  }
  /** Set the dialog content
   * @param {Element | String} content dialog content
   */
  setContentMessage(content) {
    if (content !== void 0) {
      var elt = this.getContentElement();
      if (content instanceof Element)
        element_default.setHTML(elt, "");
      element_default.setHTML(elt, content || "");
    }
  }
  /** Set the dialog title
   * @param {Element | String} content dialog content
   */
  setTitle(title) {
    var form = this.element.querySelector("form");
    form.querySelector("h2").innerText = title || "";
    if (title) {
      form.classList.add("ol-title");
    } else {
      form.classList.remove("ol-title");
    }
  }
  /** Set the dialog content
   * @param {*} options
   *  @param {Element | String} options.content dialog content
   *  @param {string} options.title title of the dialog
   *  @param {string} options.className dialog class name
   *  @param {number} options.max if not null add a progress bar to the dialog
   *  @param {number} options.progress set the progress bar value
   *  @param {Object} options.buttons a key/value list of button to show
   *  @param {function} [options.onButton] a function that takes the button id and a list of input by className
   */
  setContent(options) {
    if (!options)
      return;
    this.element.className = this.get("className");
    if (typeof options === "string")
      options = { content: options };
    options = options || {};
    this.setProgress(false);
    if (options.max)
      this.setProgress(0, options.max);
    if (options.progress !== void 0)
      this.setProgress(options.progress);
    if (this.get("zoom"))
      this.element.classList.add("ol-zoom");
    else
      this.element.classList.remove("ol-zoom");
    if (options.className) {
      options.className.split(" ").forEach((function(c) {
        this.element.classList.add(c);
      }).bind(this));
    }
    var form = this.element.querySelector("form");
    if (options.content !== void 0) {
      if (options.content instanceof Element)
        element_default.setHTML(form.querySelector(".ol-content"), "");
      element_default.setHTML(form.querySelector(".ol-content"), options.content || "");
    }
    this.setTitle(options.title);
    if (options.closeBox || this.get("closeBox") && options.closeBox !== false) {
      form.classList.add("ol-closebox");
    } else {
      form.classList.remove("ol-closebox");
    }
    var buttons = this.element.querySelector(".ol-buttons");
    buttons.innerHTML = "";
    var btn = options.buttons || this.get("buttons");
    if (btn) {
      form.classList.add("ol-button");
      for (var i in btn) {
        element_default.create("INPUT", {
          type: i === "submit" ? "submit" : "button",
          value: btn[i],
          click: this._onButton(i, options.onButton),
          parent: buttons
        });
      }
    } else {
      form.classList.remove("ol-button");
    }
  }
  /** Get dialog content element
   * @returns {Element}
   */
  getContentElement() {
    return this.element.querySelector("form .ol-content");
  }
  /** Set progress
   * @param {number|boolean} val the progress value or false to hide the progressBar
   * @param {number} max
   * @param {string|element} message
   */
  setProgress(val, max, message) {
    if (val === false) {
      element_default.setStyle(this._progress, { display: "none" });
      return;
    }
    if (max > 0) {
      this.set("max", Number(max));
    } else {
      max = this.get("max");
    }
    if (!max) {
      element_default.setStyle(this._progress, { display: "none" });
    } else {
      var p = Math.round(val / max * 100);
      element_default.setStyle(this._progress, { display: "" });
      this._progressbar.className = p ? "" : "notransition";
      element_default.setStyle(this._progressbar, { width: p + "%" });
    }
    this._progressMessage.innerHTML = "";
    element_default.setHTML(this._progressMessage, message || "");
  }
  /** Returns a function to do something on button click
   * @param {strnig} button button id
   * @param {function} callback
   * @returns {function}
   * @private
   */
  _onButton(button, callback) {
    var fn = (function(e) {
      e.preventDefault();
      if (button !== "submit" || this.get("closeOnSubmit") !== false) this.hide();
      var inputs = this.getInputs();
      this.dispatchEvent({ type: "button", button, inputs });
      if (typeof callback === "function") callback(button, inputs);
    }).bind(this);
    return fn;
  }
  /** Get inputs, textarea an select of the dialog by classname
   * @return {Object} a {key:value} list of Elements by classname
   */
  getInputs() {
    var inputs = {};
    ["input", "textarea", "select"].forEach((function(type) {
      this.element.querySelectorAll("form " + type).forEach(function(input) {
        if (input.className) {
          input.className.split(" ").forEach(function(n) {
            inputs[n] = input;
          });
        }
      });
    }).bind(this));
    return inputs;
  }
  /** Close the dialog
   */
  hide() {
    this.element.classList.remove("ol-visible");
    this.dispatchEvent({ type: "hide" });
  }
  /** Close the dialog 
   */
  close() {
    this.hide();
  }
  /** The dialog is shown
   * @return {bool} true if a dialog is open
   */
  isOpen() {
    return this.element.classList.contains("ol-visible");
  }
};
var Dialog_default = ol_control_Dialog;

// node_modules/ol-ext/util/getMapCanvas.js
var ol_ext_getMapCanvas = function(map) {
  if (!map) return null;
  var canvas = map.getViewport().getElementsByClassName("ol-fixedoverlay")[0];
  if (!canvas) {
    if (map.getViewport().querySelector(".ol-layers")) {
      canvas = document.createElement("canvas");
      canvas.className = "ol-fixedoverlay";
      map.getViewport().querySelector(".ol-layers").after(canvas);
      map.on("precompose", function(e) {
        canvas.width = map.getSize()[0] * e.frameState.pixelRatio;
        canvas.height = map.getSize()[1] * e.frameState.pixelRatio;
      });
    } else {
      canvas = map.getViewport().querySelector("canvas");
    }
  }
  return canvas;
};
var getMapCanvas_default = ol_ext_getMapCanvas;

// node_modules/ol-ext/control/CanvasBase.js
var ol_control_CanvasBase = class olcontrolCanvasBase extends Control_default {
  constructor(options) {
    options = options || {};
    super(options);
    this.setStyle(options.style);
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {ol_Map} map Map.
   * @api stable
   */
  setMap(map) {
    this.getCanvas(map);
    var oldmap = this.getMap();
    if (this._listener) {
      unByKey(this._listener);
      this._listener = null;
    }
    super.setMap(map);
    if (oldmap) {
      try {
        oldmap.renderSync();
      } catch (e) {
      }
    }
    if (map) {
      this._listener = map.on("postcompose", this._draw.bind(this));
    }
  }
  /** Get canvas overlay
   */
  getCanvas(map) {
    return getMapCanvas_default(map);
  }
  /** Get map Canvas
   * @private
   */
  getContext(e) {
    var ctx = e.context;
    if (!ctx && this.getMap()) {
      var c = this.getMap().getViewport().getElementsByClassName("ol-fixedoverlay")[0];
      ctx = c ? c.getContext("2d") : null;
    }
    return ctx;
  }
  /** Set Style
   * @api
   */
  setStyle(style) {
    this._style = style || new Style_default({});
  }
  /** Get style
   * @api
   */
  getStyle() {
    return this._style;
  }
  /** Get stroke
   * @api
   */
  getStroke() {
    var t = this._style.getStroke();
    if (!t)
      this._style.setStroke(new Stroke_default({ color: "#000", width: 1.25 }));
    return this._style.getStroke();
  }
  /** Get fill
   * @api
   */
  getFill() {
    var t = this._style.getFill();
    if (!t)
      this._style.setFill(new Fill_default({ color: "#fff" }));
    return this._style.getFill();
  }
  /** Get stroke
   * @api
   */
  getTextStroke() {
    var t = this._style.getText();
    if (!t)
      t = new Text_default({});
    if (!t.getStroke())
      t.setStroke(new Stroke_default({ color: "#fff", width: 3 }));
    return t.getStroke();
  }
  /** Get text fill
   * @api
   */
  getTextFill() {
    var t = this._style.getText();
    if (!t)
      t = new Text_default({});
    if (!t.getFill())
      t.setFill(new Fill_default({ color: "#fff" }));
    return t.getFill();
  }
  /** Get text font
   * @api
   */
  getTextFont() {
    var t = this._style.getText();
    if (!t)
      t = new Text_default({});
    if (!t.getFont())
      t.setFont("12px sans-serif");
    return t.getFont();
  }
  /** Draw the control on canvas
   * @protected
   */
  _draw() {
    console.warn("[CanvasBase] draw function not implemented.");
  }
};
var CanvasBase_default = ol_control_CanvasBase;

// node_modules/ol-ext/control/Legend.js
var ol_control_Legend = class olcontrolLegend extends CanvasBase_default {
  constructor(options) {
    options = options || {};
    var element = document.createElement("div");
    super({
      element,
      target: options.target
    });
    if (options.target) {
      element.className = options.className || "ol-legend";
    } else {
      element.className = (options.className || "ol-legend") + " ol-unselectable ol-control" + (options.collapsible === false ? " ol-uncollapsible" : " ol-collapsed");
      var button = document.createElement("button");
      button.setAttribute("type", "button");
      button.addEventListener("click", (function() {
        this.toggle();
      }).bind(this));
      element.appendChild(button);
      button = document.createElement("button");
      button.setAttribute("type", "button");
      button.className = "ol-closebox";
      button.addEventListener("click", (function() {
        this.toggle();
      }).bind(this));
      element.appendChild(button);
    }
    this._legend = options.legend;
    this._legend.getCanvas().className = "ol-legendImg";
    element.appendChild(this._legend.getCanvas());
    element.appendChild(this._legend.getListElement());
    if (options.collapsible !== false && options.collapsed === false) {
      this.show();
    }
    this._legend.on("select", (function(e) {
      this.dispatchEvent(e);
    }).bind(this));
    this._legend.on("refresh", (function() {
      if (this._onCanvas && this.getMap()) {
        try {
          this.getMap().renderSync();
        } catch (e) {
        }
      }
    }).bind(this));
    this._legend.on("items", (function(e) {
      if (e.nb) {
        this.element.classList.remove("ol-empty");
        this.element.title = options.title || "legend";
      } else {
        this.element.classList.add("ol-empty");
        this.element.title = options.emptyTitle || "no legend";
      }
      this.dispatchEvent(e);
    }).bind(this));
  }
  /** Get the legend associated with the control
   * @returns {ol_legend_Legend}
   */
  getLegend() {
    return this._legend;
  }
  /** Draw control on canvas
   * @param {boolean} b draw on canvas.
   */
  setCanvas(b) {
    this._onCanvas = b;
    this.element.style.visibility = b ? "hidden" : "visible";
    if (this.getMap()) {
      try {
        this.getMap().renderSync();
      } catch (e) {
      }
    }
  }
  /** Is control on canvas
   * @returns {boolean}
   */
  onCanvas() {
    return !!this._onCanvas;
  }
  /** Draw legend on canvas
   * @private
   */
  _draw(e) {
    if (this._onCanvas && !this.element.classList.contains("ol-collapsed")) {
      var canvas = this._legend.getCanvas();
      var ctx = this.getContext(e);
      var h = ctx.canvas.height - canvas.height;
      ctx.save();
      ctx.rect(0, h, canvas.width, canvas.height);
      var col = "#fff";
      if (this._legend.getTextStyle().getBackgroundFill()) {
        col = asString(this._legend.getTextStyle().getBackgroundFill().getColor());
      }
      ctx.fillStyle = ctx.strokeStyle = col;
      ctx.lineWidth = 10;
      ctx.lineJoin = "round";
      ctx.stroke();
      ctx.clearRect(0, h, canvas.width, canvas.height);
      ctx.fill();
      ctx.drawImage(canvas, 0, h);
      ctx.restore();
    }
  }
  /** Show control
   */
  show() {
    if (this.element.classList.contains("ol-collapsed")) {
      this.element.classList.remove("ol-collapsed");
      this.dispatchEvent({ type: "change:collapse", collapsed: false });
      if (this.getMap()) {
        try {
          this.getMap().renderSync();
        } catch (e) {
        }
      }
    }
  }
  /** Hide control
   */
  hide() {
    if (!this.element.classList.contains("ol-collapsed")) {
      this.element.classList.add("ol-collapsed");
      this.dispatchEvent({ type: "change:collapse", collapsed: true });
      if (this.getMap()) {
        try {
          this.getMap().renderSync();
        } catch (e) {
        }
      }
    }
  }
  /** Show/hide control
   * @returns {boolean}
   */
  collapse(b) {
    if (b === false)
      this.show();
    else
      this.hide();
  }
  /** Is control collapsed
   * @returns {boolean}
   */
  isCollapsed() {
    return this.element.classList.contains("ol-collapsed");
  }
  /** Toggle control
   */
  toggle() {
    this.element.classList.toggle("ol-collapsed");
    this.dispatchEvent({ type: "change:collapse", collapsed: this.element.classList.contains("ol-collapsed") });
    if (this.getMap()) {
      try {
        this.getMap().renderSync();
      } catch (e) {
      }
    }
  }
};
var Legend_default2 = ol_control_Legend;

// node_modules/ol-ext/control/Print.js
var ol_control_Print = class olcontrolPrint extends Control_default {
  constructor(options) {
    options = options || {};
    var element = element_default.create("DIV", {
      className: options.className || "ol-print"
    });
    super({
      element,
      target: options.target
    });
    if (!options.target) {
      element.classList.add("ol-unselectable", "ol-control");
      element_default.create("BUTTON", {
        type: "button",
        title: options.title || "Print",
        click: (function() {
          this.print();
        }).bind(this),
        parent: element
      });
    }
    this.set("immediate", options.immediate);
    this.set("imageType", options.imageType || "image/jpeg");
    this.set("quality", options.quality || 0.8);
    this.set("orientation", options.orientation);
  }
  /** Helper function to copy result to clipboard
   * @param {Event} e print event
   * @return {boolean}
   * @private
   */
  toClipboard(e, callback) {
    try {
      e.canvas.toBlob(function(blob) {
        try {
          navigator.clipboard.write([
            new window.ClipboardItem(
              Object.defineProperty({}, blob.type, {
                value: blob,
                enumerable: true
              })
            )
          ]);
          if (typeof callback === "function")
            callback(true);
        } catch (err) {
          if (typeof callback === "function")
            callback(false);
        }
      });
    } catch (err) {
      if (typeof callback === "function")
        callback(false);
    }
  }
  /** Helper function to copy result to clipboard
   * @param {any} options print options
   * @param {function} callback a callback function that takes a boolean if copy
   */
  copyMap(options, callback) {
    this.once("print", (function(e) {
      this.toClipboard(e, callback);
    }).bind(this));
    this.print(options);
  }
  /** Get map canvas
   * @private
   */
  _getCanvas(event, imageType, canvas) {
    var ctx;
    if (event.context) {
      canvas = event.context.canvas;
    } else {
      if (!canvas) {
        canvas = document.createElement("canvas");
        var size = this.getMap().getSize();
        canvas.width = size[0];
        canvas.height = size[1];
        ctx = canvas.getContext("2d");
        if (/jp.*g$/.test(imageType)) {
          ctx.fillStyle = this.get("bgColor") || "white";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
      } else {
        ctx = canvas.getContext("2d");
      }
      this.getMap().getViewport().querySelectorAll(".ol-layers canvas, canvas.ol-fixedoverlay").forEach((function(c) {
        if (c.width) {
          ctx.save();
          if (c.parentNode.style.opacity === "0")
            return;
          ctx.globalAlpha = parseFloat(c.parentNode.style.opacity) || 1;
          ctx.globalCompositeOperation = element_default.getStyle(c.parentNode, "mix-blend-mode");
          ctx.filter = element_default.getStyle(c.parentNode, "filter");
          var tr = element_default.getStyle(c, "transform") || element_default.getStyle(c, "-webkit-transform");
          if (/^matrix/.test(tr)) {
            tr = tr.replace(/^matrix\(|\)$/g, "").split(",");
            tr.forEach(function(t, i) {
              tr[i] = parseFloat(t);
            });
            ctx.transform(tr[0], tr[1], tr[2], tr[3], tr[4], tr[5]);
            ctx.drawImage(c, 0, 0);
          } else {
            ctx.drawImage(c, 0, 0, element_default.getStyle(c, "width"), element_default.getStyle(c, "height"));
          }
          ctx.restore();
        }
      }).bind(this));
    }
    return canvas;
  }
  /** Fast print
   * @param {*} options print options
   *  @param {HTMLCanvasElement|undefined} [options.canvas] if none create one, only for ol@6+
   *  @parama {string} options.imageType
   */
  fastPrint(options, callback) {
    options = options || {};
    if (this._ol6) {
      requestAnimationFrame((function() {
        callback(this._getCanvas({}, options.imageType, options.canvas));
      }).bind(this));
    } else {
      this.getMap().once("postcompose", (function(event) {
        if (!event.context)
          this._ol6 = true;
        callback(this._getCanvas(event, options.imageType, options.canvas));
      }).bind(this));
      this.getMap().render();
    }
  }
  /** Print the map
   * @param {Object} options
   *	@param {string} options.imageType A string indicating the image format, default the control one
   *	@param {number} options.quality Number between 0 and 1 indicating the image quality to use for image formats that use lossy compression such as image/jpeg and image/webp
   *  @param {boolean} options.immediate true to prevent delay for printing
   *  @param {boolean} [options.size=[210,297]]
   *  @param {boolean} [options.format=a4]
   *  @param {boolean} [options.orient] default control orientation
   *  @param {boolean} [options.margin=10]
   *  @param {*} options.any any options passed to the print event when fired
   * @api
   */
  print(options) {
    options = options || {};
    var imageType = options.imageType || this.get("imageType");
    var quality = options.quality || this.get("quality");
    if (this.getMap()) {
      if (options.immediate !== "silent") {
        this.dispatchEvent(Object.assign({
          type: "printing"
        }, options));
      }
      if (!options.immediate) {
        setTimeout((function() {
          options = Object.assign({}, options);
          options.immediate = "silent";
          this.print(options);
        }).bind(this), 200);
        return;
      }
      this.getMap().once(this.get("immediate") ? "postcompose" : "rendercomplete", (function(event) {
        var canvas = this._getCanvas(event, imageType);
        var size = options.size || [210, 297];
        var format = options.format || "a4";
        var w, h, position;
        var orient = options.orient || this.get("orientation");
        var margin = typeof options.margin === "number" ? options.margin : 10;
        if (canvas) {
          if (orient !== "landscape" && orient !== "portrait") {
            orient = canvas.width > canvas.height ? "landscape" : "portrait";
          }
          if (orient === "landscape")
            size = [size[1], size[0]];
          var sc = Math.min((size[0] - 2 * margin) / canvas.width, (size[1] - 2 * margin) / canvas.height);
          w = sc * canvas.width;
          h = sc * canvas.height;
          position = [(size[0] - w) / 2, (size[1] - h) / 2];
        }
        var image;
        try {
          image = canvas ? canvas.toDataURL(imageType, quality) : null;
        } catch (e2) {
          this.dispatchEvent({
            type: "error",
            canvas
          });
          return;
        }
        var e = Object.assign({
          type: "print",
          print: {
            format,
            orientation: orient,
            unit: "mm",
            size,
            position,
            imageWidth: w,
            imageHeight: h
          },
          image,
          imageType,
          quality,
          canvas
        }, options);
        this.dispatchEvent(e);
      }).bind(this));
      this.getMap().render();
    }
  }
};
var Print_default = ol_control_Print;

// node_modules/ol-ext/control/CanvasTitle.js
var ol_control_CanvasTitle = class olcontrolCanvasTitle extends CanvasBase_default {
  constructor(options) {
    options = options || {};
    var elt = element_default.create("DIV", {
      className: (options.className || "") + " ol-control-title ol-unselectable",
      style: {
        display: "block",
        visibility: "hidden"
      }
    });
    super({
      element: elt,
      style: options.style
    });
    this.setTitle(options.title || "");
    this.setVisible(options.visible !== false);
    this.element.style.font = this.getTextFont();
  }
  /**
   * Change the control style
   * @param {ol_style_Style} style
   */
  setStyle(style) {
    super.setStyle(style);
    if (this.element) {
      this.element.style.font = this.getTextFont();
    }
    if (this.getMap()) this.getMap().render();
  }
  /**
   * Set the map title
   * @param {string} map title.
   * @api stable
   */
  setTitle(title) {
    this.element.textContent = title;
    this.set("title", title);
    if (this.getMap()) {
      try {
        this.getMap().renderSync();
      } catch (e) {
      }
    }
  }
  /**
   * Get the map title
   * @param {string} map title.
   * @api stable
   */
  getTitle() {
    return this.get("title");
  }
  /**
   * Set control visibility
   * @param {bool} b
   * @api stable
   */
  setVisible(b) {
    this.element.style.display = b ? "block" : "none";
    if (this.getMap()) {
      try {
        this.getMap().renderSync();
      } catch (e) {
      }
    }
  }
  /**
   * Get control visibility
   * @return {bool}
   * @api stable
   */
  getVisible() {
    return this.element.style.display !== "none";
  }
  /** Draw title in the final canvas
   * @private
  */
  _draw(e) {
    if (!this.getVisible())
      return;
    var ctx = this.getContext(e);
    if (!ctx)
      return;
    var ratio = e.frameState.pixelRatio;
    ctx.save();
    ctx.scale(ratio, ratio);
    var eltRect = this.element.getBoundingClientRect();
    var mapRect = this.getMap().getViewport().getBoundingClientRect();
    var sc = this.getMap().getSize()[0] / mapRect.width;
    ctx.translate(
      Math.round((eltRect.left - mapRect.left) * sc),
      Math.round((eltRect.top - mapRect.top) * sc)
    );
    var h = this.element.clientHeight;
    var w = this.element.clientWidth;
    var left = w / 2;
    ctx.beginPath();
    ctx.fillStyle = asString(this.getFill().getColor());
    ctx.rect(0, 0, w, h);
    ctx.fill();
    ctx.closePath();
    ctx.beginPath();
    ctx.fillStyle = asString(this.getTextFill().getColor());
    ctx.strokeStyle = asString(this.getTextStroke().getColor());
    ctx.lineWidth = this.getTextStroke().getWidth();
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = this.getTextFont();
    ctx.lineJoin = "round";
    if (ctx.lineWidth) ctx.strokeText(this.getTitle(), left, h / 2);
    ctx.fillText(this.getTitle(), left, h / 2);
    ctx.closePath();
    ctx.restore();
  }
};
var CanvasTitle_default = ol_control_CanvasTitle;

// node_modules/ol-ext/geom/sphere.js
var ol_sphere_getMapScale = function(map, dpi) {
  var view = map.getView();
  var proj = view.getProjection();
  var center = view.getCenter();
  var px = map.getPixelFromCoordinate(center);
  px[1] += 1;
  var coord = map.getCoordinateFromPixel(px);
  var d = getDistance(
    transform(center, proj, "EPSG:4326"),
    transform(coord, proj, "EPSG:4326")
  );
  d *= (dpi || 96) / 0.0254;
  return d;
};
var ol_sphere_setMapScale = function(map, scale, dpi) {
  if (map && scale) {
    var fac = scale;
    if (typeof scale === "string") {
      scale = scale.replace(":", "/").split("/");
      fac = scale[1];
      if (!fac) fac = scale[0] || "";
      fac = fac.replace(/[^\d]/g, "");
      fac = parseInt(fac);
      if (scale[1]) {
        var num = parseInt(scale[0]);
        if (num) fac /= num;
      }
    }
    if (!fac) return;
    var view = map.getView();
    var proj = view.getProjection();
    var center = view.getCenter();
    var px = map.getPixelFromCoordinate(center);
    px[1] += 1;
    var coord = map.getCoordinateFromPixel(px);
    var d = getDistance(
      transform(center, proj, "EPSG:4326"),
      transform(coord, proj, "EPSG:4326")
    );
    d *= (dpi || 96) / 0.0254;
    view.setResolution(view.getResolution() * fac / d);
    return fac;
  }
};

// node_modules/ol-ext/control/Compass.js
var ol_control_Compass = class olcontrolCompass extends CanvasBase_default {
  constructor(options) {
    options = options || {};
    var elt = document.createElement("div");
    elt.className = "ol-control ol-compassctrl ol-unselectable ol-hidden" + (options.className ? " " + options.className : "");
    elt.style.position = "absolute";
    elt.style.visibility = "hidden";
    var style = options.style instanceof Stroke_default ? new Style_default({ stroke: options.style }) : options.style;
    if (!options.style) {
      style = new Style_default({ stroke: new Stroke_default({ width: 0 }) });
    }
    super({
      element: elt,
      style
    });
    this.set("rotateVithView", options.rotateWithView !== false);
    this.setVisible(options.visible !== false);
    this.setImage(options.image || options.src);
  }
  /** Set compass image
   * @param {Image|string} [img=default] the image or an url or 'compact' or 'default'
   */
  setImage(img) {
    if (img instanceof Image) {
      this.img_ = img;
      this.img_.onload = (function() {
        if (this.getMap()) {
          try {
            this.getMap().renderSync();
          } catch (e) {
          }
        }
      }).bind(this);
    } else if (typeof img === "string") {
      switch (img) {
        case "compact": {
          this.img_ = this.compactCompass_(this.element.clientWidth, this.getStroke().getColor());
          break;
        }
        case "default": {
          this.img_ = this.defaultCompass_(this.element.clientWidth, this.getStroke().getColor());
          break;
        }
        default: {
          this.img_ = new Image();
          this.img_.onload = (function() {
            if (this.getMap()) {
              try {
                this.getMap().renderSync();
              } catch (e) {
              }
            }
          }).bind(this);
          this.img_.src = img;
          break;
        }
      }
    } else {
      this.img_ = this.defaultCompass_(this.element.clientWidth, this.getStroke().getColor());
    }
  }
  /** Create a default image.
   * @param {number} s the size of the compass
   * @private
   */
  compactCompass_(s, color) {
    var canvas = document.createElement("canvas");
    var ctx = canvas.getContext("2d");
    s = canvas.width = canvas.height = s || 150;
    var r = s / 2;
    ctx.translate(r, r);
    ctx.fillStyle = color || "#963";
    ctx.lineWidth = 5;
    ctx.lineJoin = ctx.lineCap = "round";
    ctx.font = "bold " + r * 0.4 + "px sans-serif";
    ctx.textBaseline = "bottom";
    ctx.textAlign = "center";
    ctx.strokeStyle = "#fff";
    ctx.globalAlpha = 0.75;
    ctx.strokeText("N", 0, -r / 2);
    ctx.globalAlpha = 1;
    ctx.fillText("N", 0, -r / 2);
    ctx.beginPath();
    ctx.moveTo(0, r / 4);
    ctx.lineTo(r / 3, r / 2);
    ctx.lineTo(0, -r / 2);
    ctx.lineTo(-r / 3, r / 2);
    ctx.lineTo(0, r / 4);
    ctx.lineWidth = 12;
    ctx.fillStyle = "#fff";
    ctx.globalAlpha = 0.75;
    ctx.fill();
    ctx.stroke();
    ctx.globalAlpha = 1;
    ctx.fillStyle = ctx.strokeStyle = color || "#963";
    ctx.lineWidth = 5;
    ctx.beginPath();
    ctx.moveTo(0, r / 4);
    ctx.lineTo(0, -r / 2);
    ctx.lineTo(r / 3, r / 2);
    ctx.lineTo(0, r / 4);
    ctx.fill();
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(0, r / 4);
    ctx.lineTo(0, -r / 2);
    ctx.lineTo(-r / 3, r / 2);
    ctx.lineTo(0, r / 4);
    ctx.stroke();
    return canvas;
  }
  /** Create a default image.
   * @param {number} s the size of the compass
   * @private
   */
  defaultCompass_(s, color) {
    var canvas = document.createElement("canvas");
    var ctx = canvas.getContext("2d");
    s = canvas.width = canvas.height = s || 150;
    var r = s / 2;
    var r2 = 0.22 * r;
    function draw(r3, r22) {
      ctx.fillStyle = color || "#963";
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(r3, 0);
      ctx.lineTo(r22, r22);
      ctx.moveTo(0, 0);
      ctx.lineTo(-r3, 0);
      ctx.lineTo(-r22, -r22);
      ctx.moveTo(0, 0);
      ctx.lineTo(0, r3);
      ctx.lineTo(-r22, r22);
      ctx.moveTo(0, 0);
      ctx.lineTo(0, -r3);
      ctx.lineTo(r22, -r22);
      ctx.moveTo(0, 0);
      ctx.fill();
      ctx.stroke();
    }
    function draw2(r3, r22) {
      ctx.globalCompositeOperation = "destination-out";
      ctx.fillStyle = "#fff";
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(r3, 0);
      ctx.lineTo(r22, -r22);
      ctx.moveTo(0, 0);
      ctx.lineTo(-r3, 0);
      ctx.lineTo(-r22, r22);
      ctx.moveTo(0, 0);
      ctx.lineTo(0, r3);
      ctx.lineTo(r22, r22);
      ctx.moveTo(0, 0);
      ctx.lineTo(0, -r3);
      ctx.lineTo(-r22, -r22);
      ctx.moveTo(0, 0);
      ctx.fill();
      ctx.globalCompositeOperation = "source-over";
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(r3, 0);
      ctx.lineTo(r22, -r22);
      ctx.moveTo(0, 0);
      ctx.lineTo(-r3, 0);
      ctx.lineTo(-r22, r22);
      ctx.moveTo(0, 0);
      ctx.lineTo(0, r3);
      ctx.lineTo(r22, r22);
      ctx.moveTo(0, 0);
      ctx.lineTo(0, -r3);
      ctx.lineTo(-r22, -r22);
      ctx.moveTo(0, 0);
      ctx.stroke();
    }
    ctx.translate(r, r);
    ctx.strokeStyle = color || "#963";
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(0, 0, s * 0.41, 0, 2 * Math.PI);
    ctx.arc(0, 0, s * 0.44, 0, 2 * Math.PI);
    ctx.stroke();
    ctx.rotate(Math.PI / 4);
    draw(r * 0.9, r2 * 0.8);
    draw2(r * 0.9, r2 * 0.8);
    ctx.rotate(-Math.PI / 4);
    draw(r, r2);
    draw2(r, r2);
    return canvas;
  }
  /** Get control visibility
   * @return {boolean}
   */
  getVisible() {
    return element_default.getStyle(this.element, "display") === "block";
  }
  /** Set visibility
   * @param {boolean} b
   */
  setVisible(b) {
    if (b)
      this.element.classList.add("ol-visible");
    else
      this.element.classList.remove("ol-visible");
    if (this.getMap())
      this.getMap().render();
  }
  /** Draw compass
  * @param {ol.event} e postcompose event
  * @private
  */
  _draw(e) {
    var ctx = this.getContext(e);
    if (!ctx || !this.getVisible())
      return;
    var canvas = ctx.canvas;
    var i, da = [];
    for (i = 0; i < 8; i++)
      da[i] = [Math.cos(Math.PI * i / 8), Math.sin(Math.PI * i / 8)];
    var ratio = e.frameState.pixelRatio;
    ctx.save();
    ctx.scale(ratio, ratio);
    var w = this.element.clientWidth;
    var h = this.element.clientHeight;
    var pos = { left: this.element.offsetLeft, top: this.element.offsetTop };
    var compass = this.img_;
    var rot = e.frameState.viewState.rotation;
    ctx.beginPath();
    ctx.translate(pos.left + w / 2, pos.top + h / 2);
    if (this.get("rotateVithView"))
      ctx.rotate(rot);
    if (this.getStroke().getWidth()) {
      ctx.beginPath();
      ctx.strokeStyle = this.getStroke().getColor();
      ctx.lineWidth = this.getStroke().getWidth();
      var m = Math.max(canvas.width, canvas.height);
      for (i = 0; i < 8; i++) {
        ctx.moveTo(-da[i][0] * m, -da[i][1] * m);
        ctx.lineTo(da[i][0] * m, da[i][1] * m);
      }
      ctx.stroke();
    }
    if (compass.width) {
      ctx.drawImage(compass, -w / 2, -h / 2, w, h);
    }
    ctx.closePath();
    ctx.restore();
  }
};
var Compass_default = ol_control_Compass;

// node_modules/ol-ext/control/PrintDialog.js
var ol_control_PrintDialog = class olcontrolPrintDialog extends Control_default {
  constructor(options) {
    options = options || {};
    var element = element_default.create("DIV", {
      className: (options.className || "ol-print") + " ol-unselectable ol-control"
    });
    super({
      element
    });
    this._lang = options.lang || "en";
    if (!options.target) {
      element_default.create("BUTTON", {
        type: "button",
        title: options.title || "Print",
        click: (function() {
          this.print();
        }).bind(this),
        parent: element
      });
    }
    if (options.openWindow) {
      this.on("print", function(e) {
        if (e.canvas) {
          window.open().document.write('<img src="' + e.canvas.toDataURL() + '"/>');
        }
      });
    }
    options.target = element_default.create("DIV");
    var printCtrl = this._printCtrl = new Print_default(options);
    printCtrl.on(["print", "error", "printing"], (function(e) {
      this._printing(e);
    }).bind(this));
    this._compass = new Compass_default({
      src: options.northImage || "compact",
      visible: false,
      className: "olext-print-compass",
      style: new Stroke_default({ color: "#333", width: 0 })
    });
    var printDialog = this._printDialog = new Dialog_default({
      target: options.targetDialog || document.body,
      closeBox: true,
      className: "ol-ext-print-dialog"
    });
    var content = printDialog.getContentElement();
    this._input = {};
    var param = element_default.create("DIV", {
      className: "ol-print-param",
      parent: content
    });
    this._pages = [element_default.create("DIV", {
      className: "ol-page"
    })];
    var printMap = element_default.create("DIV", {
      className: "ol-map",
      parent: this._pages[0]
    });
    element_default.create("DIV", {
      html: this._pages[0],
      className: "ol-print-map",
      parent: content
    });
    element_default.create("H2", {
      html: this.i18n("title"),
      parent: param
    });
    var ul = element_default.create("UL", { parent: param });
    var li = element_default.create("LI", {
      /*
      html: ol_ext_element.create('LABEL', {
        html: this.18n('orientation')
      }),
      */
      className: "ol-orientation",
      parent: ul
    });
    this._input.orientation = { list: li };
    var label = element_default.create("LABEL", {
      className: "portrait",
      parent: li
    });
    this._input.orientation.portrait = element_default.create("INPUT", {
      type: "radio",
      name: "ol-print-orientation",
      value: "portrait",
      checked: true,
      on: {
        change: (function(e) {
          this.setOrientation(e.target.value);
        }).bind(this)
      },
      parent: label
    });
    element_default.create("SPAN", {
      html: this.i18n("portrait"),
      parent: label
    });
    label = element_default.create("LABEL", {
      className: "landscape",
      parent: li
    });
    this._input.orientation.landscape = element_default.create("INPUT", {
      type: "radio",
      name: "ol-print-orientation",
      value: "landscape",
      on: {
        change: (function(e) {
          this.setOrientation(e.target.value);
        }).bind(this)
      },
      parent: label
    });
    element_default.create("SPAN", {
      html: this.i18n("landscape"),
      parent: label
    });
    var s;
    li = element_default.create("LI", {
      html: element_default.create("LABEL", {
        html: this.i18n("size")
      }),
      className: "ol-size",
      parent: ul
    });
    var size = this._input.size = element_default.create("SELECT", {
      on: {
        change: (function() {
          this.setSize(size.value || originalSize);
        }).bind(this)
      },
      parent: li
    });
    for (s in this.paperSize) {
      element_default.create("OPTION", {
        html: s + (this.paperSize[s] ? " - " + this.paperSize[s][0] + "x" + this.paperSize[s][1] + " mm" : this.i18n("custom")),
        value: s,
        parent: size
      });
    }
    li = element_default.create("LI", {
      html: element_default.create("LABEL", {
        html: this.i18n("margin")
      }),
      className: "ol-margin",
      parent: ul
    });
    var margin = this._input.margin = element_default.create("SELECT", {
      on: {
        change: (function() {
          this.setMargin(margin.value);
        }).bind(this)
      },
      parent: li
    });
    for (s in this.marginSize) {
      element_default.create("OPTION", {
        html: this.i18n(s) + " - " + this.marginSize[s] + " mm",
        value: this.marginSize[s],
        parent: margin
      });
    }
    li = element_default.create("LI", {
      html: element_default.create("LABEL", {
        html: this.i18n("scale")
      }),
      className: "ol-scale",
      parent: ul
    });
    var scale = this._input.scale = element_default.create("SELECT", {
      on: {
        change: (function() {
          this.setScale(parseInt(scale.value));
        }).bind(this)
      },
      parent: li
    });
    Object.keys(this.scales).forEach((function(s2) {
      element_default.create("OPTION", {
        html: this.scales[s2],
        value: s2,
        parent: scale
      });
    }).bind(this));
    li = element_default.create("LI", {
      className: "ol-legend",
      parent: ul
    });
    var legend = element_default.createSwitch({
      html: this.i18n("legend"),
      checked: false,
      on: {
        change: (function() {
          extraCtrl.legend.control.setCanvas(legend.checked);
        }).bind(this)
      },
      parent: li
    });
    li = element_default.create("LI", {
      className: "ol-print-north",
      parent: ul
    });
    var north = this._input.north = element_default.createSwitch({
      html: this.i18n("north"),
      checked: "checked",
      on: {
        change: (function() {
          if (north.checked)
            this._compass.element.classList.add("ol-print-compass");
          else
            this._compass.element.classList.remove("ol-print-compass");
          this.getMap().render();
        }).bind(this)
      },
      parent: li
    });
    li = element_default.create("LI", {
      className: "ol-print-title",
      parent: ul
    });
    var title = element_default.createSwitch({
      html: this.i18n("mapTitle"),
      checked: false,
      on: {
        change: (function(e) {
          extraCtrl.title.control.setVisible(e.target.checked);
        }).bind(this)
      },
      parent: li
    });
    var titleText = element_default.create("INPUT", {
      type: "text",
      placeholder: this.i18n("mapTitle"),
      on: {
        keydown: function(e) {
          if (e.keyCode === 13)
            e.preventDefault();
        },
        keyup: function() {
          extraCtrl.title.control.setTitle(titleText.value);
        },
        change: (function() {
          extraCtrl.title.control.setTitle(titleText.value);
        }).bind(this)
      },
      parent: li
    });
    var userElt = element_default.create("DIV", {
      className: "ol-user-param",
      parent: param
    });
    li = element_default.create("LI", {
      className: "ol-saveas",
      parent: ul
    });
    element_default.create("DIV", {
      html: this.i18n("copied"),
      className: "ol-clipboard-copy",
      parent: li
    });
    var save = element_default.create("SELECT", {
      on: {
        change: (function() {
          var saveas = save.value;
          save.value = "";
          if (this.formats[saveas].clipboard) {
            if (this._copyMap(saveas)) return;
          }
          var format = typeof this.getSize() === "string" ? this.getSize() : null;
          var opt = Object.assign({
            format,
            size: format ? this.paperSize[format] : null,
            orient: this.getOrientation(),
            margin: this.getMargin()
          }, this.formats[saveas]);
          printCtrl.print(opt);
        }).bind(this)
      },
      parent: li
    });
    element_default.create("OPTION", {
      html: this.i18n("saveas"),
      style: { display: "none" },
      value: "",
      parent: save
    });
    this.formats.forEach((function(format, i) {
      if (format.pdf) {
        if (options.pdf === false) return;
      } else if (format.clipboard) {
        if (options.copy === false) return;
      } else if (options.save === false) {
        return;
      }
      element_default.create("OPTION", {
        html: this.i18n(format.title),
        value: i,
        parent: save
      });
    }).bind(this));
    if (save.querySelectorAll("option").length === 1) {
      save.style.display = "none";
    }
    li = element_default.create("LI", {
      className: "ol-savelegend",
      parent: ul
    });
    var copylegend = element_default.create("DIV", {
      html: this.i18n("copied"),
      className: "ol-clipboard-copy",
      parent: li
    });
    var saveLegend = element_default.create("SELECT", {
      on: {
        change: (function() {
          var clegend = extraCtrl.legend.control.getLegend().getCanvas();
          var canvas = document.createElement("CANVAS");
          canvas.width = clegend.width;
          canvas.height = clegend.height;
          var ctx = canvas.getContext("2d");
          ctx.fillStyle = "#fff";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(clegend, 0, 0);
          if (this.formats[saveLegend.value].clipboard) {
            canvas.toBlob(function(blob) {
              try {
                navigator.clipboard.write([
                  new window.ClipboardItem(
                    Object.defineProperty({}, blob.type, {
                      value: blob,
                      enumerable: true
                    })
                  )
                ]);
                copylegend.classList.add("visible");
                setTimeout(function() {
                  copylegend.classList.remove("visible");
                }, 1e3);
              } catch (err) {
              }
            }, "image/png");
          } else {
            var image;
            try {
              image = canvas.toDataURL(this.formats[saveLegend.value].imageType, this.formats[saveLegend.value].quality);
              var format = typeof this.getSize() === "string" ? this.getSize() : "A4";
              var w = canvas.width / 96 * 25.4;
              var h = canvas.height / 96 * 25.4;
              var size2 = this.paperSize[format];
              if (this.getOrientation() === "landscape")
                size2 = [size2[1], size2[0]];
              var position = [
                (size2[0] - w) / 2,
                (size2[1] - h) / 2
              ];
              this.dispatchEvent({
                type: "print",
                print: {
                  legend: true,
                  format,
                  orientation: this.getOrientation(),
                  unit: "mm",
                  size: this.paperSize[format],
                  position,
                  imageWidth: w,
                  imageHeight: h
                },
                image,
                imageType: this.formats[saveLegend.value].imageType,
                pdf: this.formats[saveLegend.value].pdf,
                quality: this.formats[saveLegend.value].quality,
                canvas
              });
            } catch (err) {
            }
          }
          saveLegend.value = "";
        }).bind(this)
      },
      parent: li
    });
    element_default.create("OPTION", {
      html: this.i18n("saveLegend"),
      style: { display: "none" },
      value: "",
      parent: saveLegend
    });
    this.formats.forEach((function(format, i) {
      element_default.create("OPTION", {
        html: this.i18n(format.title),
        value: i,
        parent: saveLegend
      });
    }).bind(this));
    var prButtons = element_default.create("DIV", {
      className: "ol-ext-buttons",
      parent: param
    });
    element_default.create("BUTTON", {
      html: this.i18n("printBt"),
      type: "submit",
      click: function(e) {
        e.preventDefault();
        window.print();
      },
      parent: prButtons
    });
    element_default.create("BUTTON", {
      html: this.i18n("cancel"),
      type: "button",
      click: function() {
        printDialog.hide();
      },
      parent: prButtons
    });
    element_default.create("DIV", {
      html: this.i18n("errorMsg"),
      className: "ol-error",
      parent: param
    });
    var originalTarget;
    var originalSize;
    var scalelistener;
    var extraCtrl = {};
    printDialog.on("show", (function() {
      this.dispatchEvent({ type: "show", userElement: userElt, dialog: this._printDialog, page: this.getPage() });
      var map = this.getMap();
      if (!map)
        return;
      document.body.classList.add("ol-print-document");
      originalTarget = map.getTargetElement();
      originalSize = map.getSize();
      if (typeof this.getSize() === "string") {
        this.setSize(this.getSize());
      } else {
        this.setSize(originalSize);
      }
      map.setTarget(printMap);
      if (scalelistener) unByKey(scalelistener);
      scalelistener = map.on("moveend", (function() {
        this.setScale(ol_sphere_getMapScale(map));
      }).bind(this));
      this.setScale(ol_sphere_getMapScale(map));
      extraCtrl = {};
      this.getMap().getControls().forEach((function(c) {
        if (c instanceof Legend_default2) {
          extraCtrl.legend = { control: c };
        }
        if (c instanceof CanvasTitle_default) {
          extraCtrl.title = { control: c };
        }
        if (c instanceof Compass_default) {
          if (extraCtrl.compass) {
            c.element.classList.remove("ol-print-compass");
          } else {
            if (this._input.north.checked)
              c.element.classList.add("ol-print-compass");
            else
              c.element.classList.remove("ol-print-compass");
            this._compass = c;
            extraCtrl.compass = { control: c };
          }
        }
      }).bind(this));
      if (extraCtrl.title) {
        title.checked = extraCtrl.title.isVisible = extraCtrl.title.control.getVisible();
        titleText.value = extraCtrl.title.control.getTitle();
        title.parentNode.parentNode.classList.remove("hidden");
      } else {
        title.parentNode.parentNode.classList.add("hidden");
      }
      if (extraCtrl.legend) {
        extraCtrl.legend.ison = extraCtrl.legend.control.onCanvas();
        extraCtrl.legend.collapsed = extraCtrl.legend.control.isCollapsed();
        extraCtrl.legend.control.collapse(false);
        saveLegend.parentNode.classList.remove("hidden");
        legend.parentNode.parentNode.classList.remove("hidden");
        legend.checked = !extraCtrl.legend.collapsed;
        extraCtrl.legend.control.setCanvas(!extraCtrl.legend.collapsed);
      } else {
        saveLegend.parentNode.classList.add("hidden");
        legend.parentNode.parentNode.classList.add("hidden");
      }
    }).bind(this));
    printDialog.on("hide", (function() {
      document.body.classList.remove("ol-print-document");
      if (!originalTarget) return;
      this.getMap().setTarget(originalTarget);
      originalTarget = null;
      if (scalelistener) unByKey(scalelistener);
      if (extraCtrl.title) {
        extraCtrl.title.control.setVisible(extraCtrl.title.isVisible);
      }
      if (extraCtrl.legend) {
        extraCtrl.legend.control.setCanvas(extraCtrl.legend.ison);
        extraCtrl.legend.control.collapse(extraCtrl.legend.collapsed);
      }
      this.dispatchEvent({ type: "hide" });
    }).bind(this));
    window.addEventListener("resize", (function() {
      this.setSize();
    }).bind(this));
    if (options.saveAs) {
      this.on("print", function(e) {
        if (!e.pdf) {
          e.canvas.toBlob(function(blob) {
            var name = (e.print.legend ? "legend." : "map.") + e.imageType.replace("image/", "");
            options.saveAs(blob, name);
          }, e.imageType, e.quality);
        }
      });
    }
    if (options.jsPDF) {
      this.on("print", function(e) {
        if (e.pdf) {
          var pdf = new options.jsPDF({
            orientation: e.print.orientation,
            unit: e.print.unit,
            format: e.print.size
          });
          pdf.addImage(e.image, "JPEG", e.print.position[0], e.print.position[0], e.print.imageWidth, e.print.imageHeight);
          pdf.save(e.print.legend ? "legend.pdf" : "map.pdf");
        }
      });
    }
  }
  /** Add a new language
   * @param {string} lang lang id
   * @param {Objetct} labels
   */
  static addLang(lang, labels) {
    ol_control_PrintDialog.prototype._labels[lang] = labels;
  }
  /** Check if the dialog is oprn
   * @return {boolean}
   */
  isOpen() {
    return this._printDialog.isOpen();
  }
  /** Translate
   * @param {string} what
   * @returns {string}
   */
  i18n(what) {
    var rep = this._labels.en[what] || what;
    if (this._labels[this._lang] && this._labels[this._lang][what]) {
      rep = this._labels[this._lang][what];
    }
    return rep;
  }
  /** Get print orientation
   * @returns {string}
   */
  getOrientation() {
    return this._orientation || "portrait";
  }
  /** Set print orientation
   * @param {string} ori landscape or portrait
   */
  setOrientation(ori) {
    this._orientation = ori === "landscape" ? "landscape" : "portrait";
    this._printDialog.element.dataset.orientation = this._orientation;
    this._input.orientation[this._orientation].checked = true;
    this.setSize();
  }
  /** Get print margin
   * @returns {number}
   */
  getMargin() {
    return this._margin || 0;
  }
  /** Set print margin
   * @param {number}
   */
  setMargin(margin) {
    this._margin = margin;
    this._input.margin.value = margin;
    this.setSize();
  }
  /** Get print size
   * @returns {ol.size}
   */
  getSize() {
    return this._size;
  }
  /** Set map print size
   * @param {ol/size|string} size map size as ol/size or A4, etc.
   */
  setSize(size) {
    this._printDialog.getContentElement().dataset.status = "";
    if (size) {
      this._size = size;
    } else {
      size = this._size;
    }
    if (!size) return;
    if (typeof size === "string") {
      for (var k in this.paperSize) {
        if (k && new RegExp(k, "i").test(size)) {
          size = k;
        }
      }
      if (!this.paperSize[size])
        size = this._size = "A4";
      this._input.size.value = size;
      size = [
        Math.trunc(this.paperSize[size][0] * 96 / 25.4),
        Math.trunc(this.paperSize[size][1] * 96 / 25.4)
      ];
      if (this.getOrientation() === "landscape") {
        size = [size[1], size[0]];
      }
      this.getPage().classList.remove("margin");
    } else {
      this._input.size.value = "";
      this.getPage().classList.add("margin");
    }
    var printElement = this.getPage();
    var s = printElement.parentNode.getBoundingClientRect();
    var scx = (s.width - 40) / size[0];
    var scy = (s.height - 40) / size[1];
    var sc = Math.min(scx, scy, 1);
    printElement.style.width = size[0] + "px";
    printElement.style.height = size[1] + "px";
    printElement.style["-webkit-transform"] = printElement.style.transform = "translate(-50%,-50%) scale(" + sc + ")";
    var px = Math.round(5 / sc);
    printElement.style["-webkit-box-shadow"] = printElement.style["box-shadow"] = px + "px " + px + "px " + px + "px rgba(0,0,0,.6)";
    printElement.style["padding"] = this.getMargin() * 96 / 25.4 + "px";
    if (this.getMap()) {
      this.getMap().updateSize();
    }
    this.dispatchEvent({ type: "dialog:refresh" });
  }
  /** Dispatch print events
   * @private
   */
  _printing(e) {
    this._printDialog.getContentElement().dataset.status = e.type;
    if (!e.clipboard) {
      this.dispatchEvent(e);
    }
  }
  /** Copy map to clipboard
   * @param {string} format
   * @return {boolean} if copy
   * @private
   */
  _copyMap(format) {
    var copied = this._printDialog.element.querySelector(".ol-clipboard-copy");
    this._printCtrl.copyMap(this.formats[format], function(isok) {
      if (isok) {
        copied.classList.add("visible");
        setTimeout(function() {
          copied.classList.remove("visible");
        }, 1e3);
      }
    });
    return true;
  }
  /** Get dialog content element
   * @return {Element}
   */
  getContentElement() {
    return this._printDialog.getContentElement();
  }
  /** Get dialog user element
   * @return {Element}
   */
  getUserElement() {
    return this._printDialog.getContentElement().querySelector(".ol-user-param");
  }
  /** Get page element
   * @return {Element}
   */
  getPage() {
    return this._pages[0];
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {ol.Map} map Map.
   * @api stable
   */
  setMap(map) {
    if (this.getMap()) {
      this.getMap().removeControl(this._compass);
      this.getMap().removeControl(this._printCtrl);
      this.getMap().removeControl(this._printDialog);
    }
    super.setMap(map);
    if (this.getMap()) {
      this.getMap().addControl(this._compass);
      this.getMap().addControl(this._printCtrl);
      this.getMap().addControl(this._printDialog);
    }
  }
  /** Set the current scale (will change the scale of the map)
   * @param {number|string} value the scale factor or a scale string as 1/xxx
   */
  setScale(value) {
    ol_sphere_setMapScale(this.getMap(), value);
    this._input.scale.value = " " + Math.round(value / 100) * 100;
  }
  /** Get the current map scale factor
   * @return {number}
   */
  getScale() {
    return ol_sphere_getMapScale(this.getMap());
  }
  /** Show print dialog
   * @param {*}
   *  @param {ol/size|string} options.size map size as ol/size or A4, etc.
   *  @param {number|string} options.value the scale factor or a scale string as 1/xxx
   *  @param {string} options.orientation landscape or portrait
   *  @param {number} options.margin
   */
  print(options) {
    options = options || {};
    if (options.size) this.setSize(options.size);
    if (options.scale) this.setScale(options.scale);
    if (options.orientation) this.setOrientation(options.orientation);
    if (options.margin) this.setMargin(options.margin);
    this._printDialog.show();
  }
  /** Get print control
   * @returns {ol_control_Print}
   */
  getPrintControl() {
    return this._printCtrl;
  }
};
ol_control_PrintDialog.prototype._labels = {
  en: {
    title: "Print",
    orientation: "Orientation",
    portrait: "Portrait",
    landscape: "Landscape",
    size: "Page size",
    custom: "screen size",
    margin: "Margin",
    scale: "Scale",
    legend: "Legend",
    north: "North arrow",
    mapTitle: "Map title",
    saveas: "Save as...",
    saveLegend: "Save legend...",
    copied: "✔ Copied to clipboard",
    errorMsg: "Can't save map canvas...",
    printBt: "Print...",
    clipboardFormat: "copy to clipboard...",
    jpegFormat: "save as jpeg",
    pngFormat: "save as png",
    pdfFormat: "save as pdf",
    none: "none",
    small: "small",
    large: "large",
    cancel: "cancel"
  },
  fr: {
    title: "Imprimer",
    orientation: "Orientation",
    portrait: "Portrait",
    landscape: "Paysage",
    size: "Taille du papier",
    custom: "taille écran",
    margin: "Marges",
    scale: "Echelle",
    legend: "Légende",
    north: "Flèche du nord",
    mapTitle: "Titre de la carte",
    saveas: "Enregistrer sous...",
    saveLegend: "Enregistrer la légende...",
    copied: "✔ Carte copiée",
    errorMsg: "Impossible d'enregistrer la carte",
    printBt: "Imprimer",
    clipboardFormat: "copier dans le presse-papier...",
    jpegFormat: "enregistrer un jpeg",
    pngFormat: "enregistrer un png",
    pdfFormat: "enregistrer un pdf",
    none: "aucune",
    small: "petites",
    large: "larges",
    cancel: "annuler"
  },
  de: {
    title: "Drucken",
    orientation: "Ausrichtung",
    portrait: "Hochformat",
    landscape: "Querformat",
    size: "Papierformat",
    custom: "Bildschirmgröße",
    margin: "Rand",
    scale: "Maßstab",
    legend: "Legende",
    north: "Nordpfeil",
    mapTitle: "Kartentitel",
    saveas: "Speichern als...",
    saveLegend: "Legende speichern...",
    copied: "✔ In die Zwischenablage kopiert",
    errorMsg: "Kann Karte nicht speichern...",
    printBt: "Drucken...",
    clipboardFormat: "in die Zwischenablage kopieren...",
    jpegFormat: "speichern als jpeg",
    pngFormat: "speichern als png",
    pdfFormat: "speichern als pdf",
    none: "kein",
    small: "klein",
    large: "groß",
    cancel: "abbrechen"
  },
  zh: {
    title: "打印",
    orientation: "方向",
    portrait: "纵向",
    landscape: "横向",
    size: "页面大小",
    custom: "屏幕大小",
    margin: "外边距",
    scale: "尺度",
    legend: "图例",
    north: "指北针",
    mapTitle: "地图名字",
    saveas: "保存为...",
    saveLegend: "保存图例为...",
    copied: "✔ 已复制到剪贴板",
    errorMsg: "无法保存地图...",
    printBt: "打印...",
    cancel: "取消"
  }
};
ol_control_PrintDialog.prototype.paperSize = {
  "": null,
  "A0": [841, 1189],
  "A1": [594, 841],
  "A2": [420, 594],
  "A3": [297, 420],
  "A4": [210, 297],
  "US Letter": [215.9, 279.4],
  "A5": [148, 210],
  "B4": [257, 364],
  "B5": [182, 257]
};
ol_control_PrintDialog.prototype.marginSize = {
  none: 0,
  small: 5,
  large: 10
};
ol_control_PrintDialog.prototype.formats = [
  {
    title: "clipboardFormat",
    imageType: "image/png",
    clipboard: true
  },
  {
    title: "jpegFormat",
    imageType: "image/jpeg",
    quality: 0.8
  },
  {
    title: "pngFormat",
    imageType: "image/png",
    quality: 0.8
  },
  {
    title: "pdfFormat",
    imageType: "image/jpeg",
    pdf: true
  }
];
ol_control_PrintDialog.prototype.scales = {
  " 5000": "1/5.000",
  " 10000": "1/10.000",
  " 25000": "1/25.000",
  " 50000": "1/50.000",
  " 100000": "1/100.000",
  " 250000": "1/250.000",
  " 1000000": "1/1.000.000"
};
var PrintDialog_default = ol_control_PrintDialog;
export {
  PrintDialog_default as default
};
//# sourceMappingURL=ol-ext_control_PrintDialog.js.map
